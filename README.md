# formapp
This repository provides a base project to learn a simple HTML form application.

The project can be built with either Docker or Go 1.17.

It depends on [Gin Web Framework](https://pkg.go.dev/github.com/gin-gonic/gin) for ease of implementation.
Gin will be donloaded automatically.

You can run the server with the following commands;
```sh
$ docker-compose up -d
$ docker-compose exec app go run main.go
```
Or, you can directly execute `go run main.go` if you have Go development tools.

The execution command downloads Gin framework from the Internet, thus your PC is required to be online and the server may require a couple of minutes until start working.

## Git

Visual Studio Code上で git push をしようとすると fork 元の upstreamがデフォルトになっているようでpermission denied になる。そのため、pushを行う際は、forkしたリポジトリを明示的に指定する必要がある。

```sh
git push origin <branch name>
```

## Go module Installation

go module を下記のコマンドでインストールすることができる。

  ```sh
  go mod tidy
  ```

[go mod tidyに関してまとめているブログ](https://developer.so-tech.co.jp/entry/2022/08/16/110108)


公式ドキュメント

https://go.dev/doc/tutorial/getting-started


以下引用

### Call code in an external package

When you need your code to do something that might have been implemented by someone else, you can look for a package that has functions you can use in your code.

Make your printed message a little more interesting with a function from an external module.
Visit pkg.go.dev and search for a "quote" package.
Locate and click the rsc.io/quote package in search results (if you see rsc.io/quote/v3, ignore it for now).
In the Documentation section, under Index, note the list of functions you can call from your code. You'll use the Go function.
At the top of this page, note that package quote is included in the rsc.io/quote module.
You can use the pkg.go.dev site to find published modules whose packages have functions you can use in your own code. Packages are published in modules -- like rsc.io/quote -- where others can use them. Modules are improved with new versions over time, and you can upgrade your code to use the improved versions.

In your Go code, import the rsc.io/quote package and add a call to its Go function.
After adding the highlighted lines, your code should include the following:

```go
package main

import "fmt"

import "rsc.io/quote"

func main() {
    fmt.Println(quote.Go())
}
```

Add new module requirements and sums.
Go will add the quote module as a requirement, as well as a go.sum file for use in authenticating the module. For more, see Authenticating modules in the Go Modules Reference.

```sh
$ go mod tidy
go: finding module for package rsc.io/quote
go: found rsc.io/quote in rsc.io/quote v1.5.2
```

Run your code to see the message generated by the function you're calling.
```sh
$ go run .
```
Don't communicate by sharing memory, share memory by communicating.
Notice that your code calls the Go function, printing a clever message about communication.

When you ran go mod tidy, it located and downloaded the rsc.io/quote module that contains the package you imported. By default, it downloaded the latest version -- v1.5.2.

### `go mod tidy`

公式: https://go.dev/ref/mod#go-mod-tidy

Usage:

go mod tidy [-e] [-v] [-go=version] [-compat=version]
go mod tidy ensures that the go.mod file matches the source code in the module. It adds any missing module requirements necessary to build the current module’s packages and dependencies, and it removes requirements on modules that don’t provide any relevant packages. It also adds any missing entries to go.sum and removes unnecessary entries.

The -e flag (added in Go 1.16) causes go mod tidy to attempt to proceed despite errors encountered while loading packages.

The -v flag causes go mod tidy to print information about removed modules to standard error.

go mod tidy works by loading all of the packages in the main module and all of the packages they import, recursively. This includes packages imported by tests (including tests in other modules). go mod tidy acts as if all build tags are enabled, so it will consider platform-specific source files and files that require custom build tags, even if those source files wouldn’t normally be built. There is one exception: the ignore build tag is not enabled, so a file with the build constraint // +build ignore will not be considered. Note that go mod tidy will not consider packages in the main module in directories named testdata or with names that start with . or _ unless those packages are explicitly imported by other packages.

Once go mod tidy has loaded this set of packages, it ensures that each module that provides one or more packages has a require directive in the main module’s go.mod file or — if the main module is at go 1.16 or below — is required by another required module. go mod tidy will add a requirement on the latest version of each missing module (see Version queries for the definition of the latest version). go mod tidy will remove require directives for modules that don’t provide any packages in the set described above.

go mod tidy may also add or remove // indirect comments on require directives. An // indirect comment denotes a module that does not provide a package imported by a package in the main module. (See the require directive for more detail on when // indirect dependencies and comments are added.)

If the -go flag is set, go mod tidy will update the go directive to the indicated version, enabling or disabling module graph pruning and lazy module loading (and adding or removing indirect requirements as needed) according to that version.

By default, go mod tidy will check that the selected versions of modules do not change when the module graph is loaded by the Go version immediately preceding the version indicated in the go directive. The versioned checked for compatibility can also be specified explicitly via the -compat flag.

### パッケージを探すには

上記にもあるように、パッケージを探す場合は以下のリンクから探すのが良いらしい

https://pkg.go.dev/


